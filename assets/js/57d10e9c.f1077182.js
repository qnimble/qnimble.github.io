(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{82:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return g}));var i=n(3),r=n(7),a=(n(0),n(110)),s={title:"Measuring Response Time",hide_title:!0},o={unversionedId:"AppNotes/MeasureLatency",id:"AppNotes/MeasureLatency",isDocsHomePage:!1,title:"Measuring Response Time",description:"Measuring Response Time (Latency & Jitter)",source:"@site/quarto/AppNotes/MeasureLatency.md",slug:"/AppNotes/MeasureLatency",permalink:"/Quarto/AppNotes/MeasureLatency",version:"current",sidebar:"quarto_main_sidebar",previous:{title:"Triggers",permalink:"/Quarto/Software/Triggers"}},l=[{value:"Overview",id:"overview",children:[]},{value:"Trigger Interrupt Latency",id:"trigger-interrupt-latency",children:[]},{value:"Real World",id:"real-world",children:[]}],c={toc:l};function g(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"measuring-response-time-latency--jitter"},"Measuring Response Time (Latency & Jitter)"),Object(a.b)("h2",{id:"overview"},"Overview"),Object(a.b)("p",null,"Whenever you want to interrupt what the MCU is doing to handle something else, you use an interrupt to cause that interruption.  When new ADC data is ready, we use an interrupt to process that new data. Similarly when the USB has incoming data, it will use an interrupt so the MCU can receive the data. Additionally, the ",Object(a.b)("em",{parentName:"p"},"Quarto")," can configure the trigger lines to act as interrupts so the user can externally interrupt the processor. "),Object(a.b)("p",null,"One of the key performance specifications of the ",Object(a.b)("em",{parentName:"p"},"Quarto")," is how fast it can respond an event (new data, an external trigger, etc). To measure this, we want to measure the time it takes for the MCU to respond to an interrupt (often called the interrupt latency).  Regardless of the causes of the trigger, the MCU must stop what it is doing and switch to running the function assigned the interrupt that fired. How long this takes depends on what the MCU was in middle of doing."),Object(a.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(a.b)("div",{parentName:"div",className:"admonition-heading"},Object(a.b)("h5",{parentName:"div"},Object(a.b)("span",{parentName:"h5",className:"admonition-icon"},Object(a.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(a.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Interrupt Priority")),Object(a.b)("div",{parentName:"div",className:"admonition-content"},Object(a.b)("p",{parentName:"div"},"In this application note, we will assume that the interrupt we care about is running at the highest priority. If you have multiple interrupts firing then anything with a lower priority will have to wait for all the higher priority interrupts to complete before they can execute. Additionally, these interrupts can have their execution paused to process a lower priority interrupt."))),Object(a.b)("h2",{id:"trigger-interrupt-latency"},"Trigger Interrupt Latency"),Object(a.b)("p",null,"In this example, we will measure the interrupt latency from an external trigger, although the data would look the same for new ADC data as well. Here is basic code for responding to the rising edge on the Trigger 1 line."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-c"},"void setup() {  \n  setTrigger2Direction(PIN_DIRECTION_OUTPUT); // Use Trigger 2 as output\n  enableInterruptTrigger1(true, gotTrigger); // Run gotTrigger on Trigger 1 rising edge\n}\n\nstatic unsigned int triggers = 0; //store how many triggers have happened\n\nvoid gotTrigger(void) {\n  clearISRTrigger1(); // *** Clears interrupt, this **must** be run at start of function!!\n  setTrigger2High(); // Set Trigger 2 high so when know when function fires\n  \n  delayNanoseconds(50); // Function runs too fast to see Trigger 2 pulse on O-scope otherwise\n  triggers++;\n  if (triggers % 2 == 0) {\n    writeDACRAW1(16000); //Write to DAC on even number of triggers\n  } else {\n    writeDACRAW1(-16000); //Write negative value on odd number of triggers\n  }\n  \n  setTrigger2Low(); // Set Trigger 2 low when function complete\n}\n")),Object(a.b)("p",null,"An Oscilloscope is configured to display with 10s of persistence we we can see multiple takes on the same screen. The cyan trace shows Trigger 1 and yellow shows Trigger 2."),Object(a.b)("img",{className:"center",src:"/img/isr-latency-p1.png"}),Object(a.b)("p",null,"The Trigger 2 goes high about  125ns after the Trigger 1 goes high. So the Interrupt Latency is approximately 125ns. The ",Object(a.b)("inlineCode",{parentName:"p"},"gotTrigger()")," function finishes executing about 50ns later, which makes sense given the 50ns delay in that function. Because of the persistence setup on the oscilloscope, the yellow trace is broadened by the timing jitter, as sometimes the response is a little faster or slower. But this is on the order of only 10ns. "),Object(a.b)("p",null,"While 125ns latency is terrific, this is under ideal circumstances. The ",Object(a.b)("em",{parentName:"p"},"Quarto")," is doing nothing besides waiting for the Trigger 1 interrupt to happen, so it does not have to stop what it is doing to respond. "),Object(a.b)("h2",{id:"real-world"},"Real World"),Object(a.b)("p",null,"The previous code generated a nice baseline, however, the MCU was never doing anything except handling the Trigger 1 interrupt, so it was in an ideal position to respond quickly. Realistically, the MCU will be busy handling USB data and doing other tasks in the main loop. This will add jitter to the latency as sometimes the MCU is idle and sometimes it has to store what it is working to memory before it can respond to the interrupt. To model this better, we've added a new loop function that the MCU continuously runs. In the loop, we do a few things"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"USB: echo back any USB data that is received"),Object(a.b)("li",{parentName:"ul"},"Math: Do a math calculation all the time in the loop function"),Object(a.b)("li",{parentName:"ul"},"LED: Toggle the front panel LED every 500ms")),Object(a.b)("p",null,"The new code is:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-c"},"void setup() {  \n  setTrigger2Direction(PIN_DIRECTION_OUTPUT); // Use Trigger 2 as output\n  enableInterruptTrigger1(true, gotTrigger); // Run gotTrigger on Trigger 1 rising edge\n}\n\nstatic unsigned int triggers = 0; //store how many triggers have happened\n\nvoid gotTrigger(void) {\n  clearISRTrigger1(); // *** Clears interrupt, this **must** be run at start of function!!\n  setTrigger2High(); // Set Trigger 2 high so when know when function fires\n  \n  delayNanoseconds(50); // Function runs too fast to see Trigger 2 pulse on O-scope otherwise\n  triggers++;\n  if (triggers % 2 == 0) {\n    writeDACRAW1(16000); //Write to DAC on even number of triggers\n  } else {\n    writeDACRAW1(-16000); //Write negative value on odd number of triggers\n  }\n  \n  setTrigger2Low(); // Set Trigger 2 low when function complete\n}\nvoid loop() {\n  static unsigned long lastrun;\n  static signed long total;\n\n  if (millis() > lastrun + 500) { //Run once every 500ms            \n    toggleLEDGreen(); //toggle green LED;            \n    lastrun = lastrun + 500;\n  }\n\n  total += 324*(total-2343); //do some math in main loop\n\n  char dat;\n  while (Serial.available() > 0) {\n    dat = Serial.read(); //Read USB data if available\n    Serial.print(dat); //Echo data back over USB\n  }  \n}\n")),Object(a.b)("p",null,"An external function generate was used to have Trigger 1 go high at 1 MHz (once per \u03bcs) and a python script was used to stream data into and out of the ",Object(a.b)("em",{parentName:"p"},"Quarto")," at ~18 Mbps in both directions. While all this was happening, let's look at the response time again with the oscilloscope set at 10s persistence: "),Object(a.b)("img",{className:"center",src:"/img/isr-latency-p2.png"}),Object(a.b)("p",null,"The response it still usually 125ns, however over 10s there are numerous events where the latency is higher. Especially when using the ",Object(a.b)("em",{parentName:"p"},"Quarto")," for servoing, just as important as the response time is how consistent the response time is. In the worst case Trigger 2 falls 250ns after the rising Trigger 1. That 250 ns includes the interrupt latency, the function execution time and the timing jitter.  With the minimal latency of 125ns and the function taking 50ns to run, the jitter is the remainder: 250ns - 125ns - 50ns = 75ns. So the interrupt latency is bounded to be better than about 200ns. Which is excellent. "),Object(a.b)("p",null,"In the example of the ",Object(a.b)("a",{parentName:"p",href:"../Examples/Servo"},"PID Servo")," the full system latency is a little over 4\u03bcs, so 75ns of timing jitter is <2%, so a very small effect."))}g.isMDXComponent=!0}}]);