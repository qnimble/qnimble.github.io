"use strict";(self.webpackChunkdoc_source=self.webpackChunkdoc_source||[]).push([[8370],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return p}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(n),p=r,m=c["".concat(l,".").concat(p)]||c[p]||h[p]||a;return n?o.createElement(m,i(i({ref:t},d),{},{components:n})):o.createElement(m,i({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<a;u++)i[u]=n[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2365:function(e,t,n){n.d(t,{X2:function(){return a},Z6:function(){return s},h4:function(){return i},sg:function(){return r}});var o=n(7294),r=function(e){var t=e.children,n=e.width,r=void 0===n?"6":n,a=e.align,i=void 0===a?"left":a;return o.createElement("div",{className:"col col--"+r+" text--"+i},t)},a=function(e){var t=e.children;return o.createElement("div",{className:"row"},t)},i=function(e){var t=e.children;return o.createElement("h1",null,t)},s=function(e){var t=e.children;return o.createElement("div",{className:"specs"},t)}},8265:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return h}});var o=n(3117),r=n(102),a=(n(7294),n(3905)),i=(n(2365),["components"]),s={id:"Troubleshooting",sidebar_label:"Troubleshooting Guide",sidebar_position:40,title:"Troubleshooting Guide",hide_title:!1,hide_table_of_contents:!1,keywords:["Troubleshooting","Errors","Problems","FAQ"],description:"Troubleshooting guide for the qNimble Quarto"},l=void 0,u={unversionedId:"Troubleshooting",id:"Troubleshooting",title:"Troubleshooting Guide",description:"Troubleshooting guide for the qNimble Quarto",source:"@site/Quarto/Troubleshooting.md",sourceDirName:".",slug:"/Troubleshooting",permalink:"/Quarto/Troubleshooting",draft:!1,tags:[],version:"current",sidebarPosition:40,frontMatter:{id:"Troubleshooting",sidebar_label:"Troubleshooting Guide",sidebar_position:40,title:"Troubleshooting Guide",hide_title:!1,hide_table_of_contents:!1,keywords:["Troubleshooting","Errors","Problems","FAQ"],description:"Troubleshooting guide for the qNimble Quarto"},sidebar:"autoSideBar",previous:{title:"Frequently Asked Questions",permalink:"/Quarto/FAQ"},next:{title:"Program Examples",permalink:"/Quarto/Examples/"}},d={},h=[{value:"Crashing",id:"crashing",level:2},{value:"Timeout Crashes",id:"timeout-crashes",level:3},{value:"Example",id:"example",level:4},{value:"Detected Hard Crashes",id:"detected-hard-crashes",level:3},{value:"Undetected Hard Crashes",id:"undetected-hard-crashes",level:3},{value:"Fixing a Timeout Crash",id:"fixing-a-timeout-crash",level:2}],c={toc:h};function p(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"crashing"},"Crashing"),(0,a.kt)("p",null,"If you tell the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," to do something impossible, like most computers, it will go ahead and try. And fail. When this happens, the Quarto will usually crash. In most cases when this happens, the Quarto will detect the crash and reboot into the bootloader where you can further troubleshoot if desired or just upload different code. There are three main types of crashes:"),(0,a.kt)("h3",{id:"timeout-crashes"},"Timeout Crashes"),(0,a.kt)("p",null,"Let's say you write a function that runs forever:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"void runForever(void) {\n    while(1) {\n        do_something(); //run over and over again forever\n    }\n}\n")),(0,a.kt)("p",null,"If you put that function inside the loop() function, the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," will happily run that program forever. USB communication will continue to work because the USB uses interrupts to temporarily pause that main loop to handle the USB tasks. Incoming ADC data also uses interrupts to pause execution of the main code."),(0,a.kt)("p",null,"However, if you put that function that runs forever inside an interrupt, then the interrupt will never finish and other interrupts, like the USB and ADC processing routines, will never run. USB communication will stop. While technically the Quarto hasn't crashed -- it is still running your forever loop -- it has functionally crashed because you can no longer talk to it and it cannot process new ADC data. "),(0,a.kt)("p",null,"After about 5 seconds in this state, the ",(0,a.kt)("em",{parentName:"p"},"Quarto"),' will reboot itself into the boot loader. The status LED will alternate between red and blue, indicating there was a timeout crash. From this state, you can upload new code to fix the problem. Additionally, with bootloader 0.5.0 and higher, can you get more detailed information about the crash by typing "c#" into the bootloader. '),(0,a.kt)("p",null,"Now you don't need an infinite loop to create this kind of crash. If you have an ADC interrupt firing every 1\xb5s, then if that interrupt takes longer than 1\xb5s to complete, then the next interrupt will want to run before the first one finishes. So the Quarto will jump directly from the running the interrupt the first time to running it the second time. And then the third time, etc and the Quarto will never run other code, so the USB will fail and we again have a timeout crash. "),(0,a.kt)("img",{align:"right",src:"../img/arduino_board_version1p4.png"}),(0,a.kt)("h4",{id:"example"},"Example"),(0,a.kt)("p",null,"Please make sure you are running version 1.4.0 or higher of the qNimble iMXRT boards as earlier versions did not always detect crashes and reboot, so crashes on older software may require a physical power reboot."),(0,a.kt)("p",null,"In the program below, we configure the ADC to fire once every 1\xb5s, but in the interrupt routine that handles new ADC data, we put a 1000 ns delay. Now there is no way the routine can finish in under a 1\xb5s, so the processor won't be able to keep up with the interrupts and will spend all its time handling that interrupt and ignoring everything, causing a timeout crash."),(0,a.kt)("div",{style:{clear:"right",padding:"0 0 10px 0"}}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="This will crash the Quarto"',title:'"This',will:!0,crash:!0,the:!0,'Quarto"':!0},'void setup() {\n  configureADC(1,1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n}\n\nvoid loop(void) {\n  static unsigned long lastrun = 0;    \n  if (millis() > lastrun) { //Run once every 250ms\n      lastrun = millis() + 250;\n      toggleLEDGreen();\n      Serial.println("+");            \n  }\n}\n\nvoid getADC1(void) {\n  double newdata = readADC1_from_ISR(); //read ADC voltage\n  writeDAC(1,newdata);\n  delayNanoseconds(1000); //Serial.print lines are slow commands that can also cause timouet crashes\n}\n')),(0,a.kt)("p",null,"When the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," crashes, it will reboot into the bootloader (flashing blue and red) and we can enter in 'c#' to get the crash report."),(0,a.kt)("img",{className:"center",src:"../img/arduino-crashreport1.png"}),(0,a.kt)("p",null,"Now since the Quarto didn't technically crash (it just became unresponsive), there is no crash report. However, the User-set debug word can be very helpful. The function ",(0,a.kt)("inlineCode",{parentName:"p"},"setDebugWord")," can be used to set a ",(0,a.kt)("inlineCode",{parentName:"p"},"uint32_t"),"  that will be maintained, and later read,after a reboot. So, if we want to time the crash, we can call setDebugWord in our ISR to see when it crashes. Here's the new code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="Time the crash"',title:'"Time',the:!0,'crash"':!0},'uint start_time;\nvoid setup() {\n  start_time = rtc_get(); //record time when application started\n  configureADC(1,1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n}\n\nvoid loop(void) {\n  static unsigned long lastrun = 0;      \n  if (millis() > lastrun) { //Run once every 250ms\n      lastrun = millis() + 250;\n      toggleLEDGreen();\n      Serial.println("+");\n  }\n}\n\nvoid getADC1(void) {\n  uint time = rtc_get() - start_time;\n  setDebugWord(time);\n  double newdata = readADC1_from_ISR(); //read ADC voltage\n  writeDAC(1,newdata);\n  delayNanoseconds(1000); //Serial.print lines are slow commands that can also cause timouet crashes\n}\n')),(0,a.kt)("p",null,"Now, when we run 'c#' in the bootloader, the User-set Debug word is 0x05, meaning the code ran for 5 seconds before the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," reboot, which is the expected timeout time. Note that we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"rtc_get()")," command to get the time (in seconds) and not ",(0,a.kt)("inlineCode",{parentName:"p"},"millis()")," because while ",(0,a.kt)("inlineCode",{parentName:"p"},"millis()")," offers more timing precision, it uses interrupts to gets its time, so the measurement is not accurate during a timeout crash."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"In general, you want interrupt routines such as the getADC1 to do as little as possible, so they can run quickly and complete. If you want to print out the ADC data, its better to have the getADC1 store the data and then via a timer or the main loop print out that data. Similarlly, if you want to process the ADC data, often it is better to store it in the getADC1 routine and once you have a set amount of data, process that data as a batch with a function called from the main loop or timer. ")),(0,a.kt)("h3",{id:"detected-hard-crashes"},"Detected Hard Crashes"),(0,a.kt)("p",null,"The second type of crash is where the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," truly locks up and no longer does any processing. There are a variety of actions that can cause this, almost all involving advanced usage. The most common cause is to read or write from an invalid or protected memory address. This can happen indirectly if you have data corruption or a buffer overflow, or directly by explicitly writing to specific memory. In this example we will write to a couple of memory address and use the ",(0,a.kt)("inlineCode",{parentName:"p"},"setDebugWord")," function to find out which memory write caused the problem. "),(0,a.kt)("p",null,"Below is an example. In this code, we create a pointer that we manually set to arbitrary memory addresses to access memory. This should almost always be avoided because it enables the kinds of mistakes were are demonstrating here. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="Create Hard Crash from Memory Violation"',title:'"Create',Hard:!0,Crash:!0,from:!0,Memory:!0,'Violation"':!0},"void setup() {\n  setDebugWord(0x11111111); //Got to start of program\n  uint* ptr; //create a pointer so we can write to arbitrary memory addresses\n  setDebugWord(0x11112222);\n  ptr = 0x80001234; //set memory address\n  *ptr = 256; //set value of that memory address to 256\n  setDebugWord(0x33334444);\n  ptr = 0xb0001234; //set memory address\n  *ptr = 256; //set value of new memory address to 256\n  setDebugWord(0x66667777);\n  ptr = 0x20001234; //set memory address\n  *ptr = 256; //set value of another memory address to 256\n}\n")),(0,a.kt)("p",null,"Now when the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," crashes and reboots, the bootloader will flash red and green show a hard crash instead of a timeout. With bootloader version 0.5.0 and higher, we also get a crash report from the 'c#' command:"),(0,a.kt)("img",{className:"center",src:"../img/arduino-crashreport2.png"}),(0,a.kt)("p",null,"From this output, we can see a few things. The Debug word was ",(0,a.kt)("inlineCode",{parentName:"p"},"0x33334444")," so the crash occured when writing to that second memory address ",(0,a.kt)("inlineCode",{parentName:"p"},"0xb0001234")," . The crash report confirms this, explicity showing that the accessed memory violation was at ",(0,a.kt)("inlineCode",{parentName:"p"},"0xB0001234"),". For advanced users, the fact that the crash happened when executing code at address ",(0,a.kt)("inlineCode",{parentName:"p"},"0x62")," could also be used for debugging the problem. "),(0,a.kt)("h3",{id:"undetected-hard-crashes"},"Undetected Hard Crashes"),(0,a.kt)("p",null,"Ideally, any crash of the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," would be detected and the device will reboot into the bootloader. However, it is possible to disabled the reboot functionality or otherwise stop this process from working. In this case, you may get a pop-up message from the operating system that it is no longer able to communicate with serial port the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," is set to. When this happens, the only solution is to reboot the ",(0,a.kt)("em",{parentName:"p"},"Quarto"),". This can be done in two ways:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Disconnect and reconnect power to the device"),(0,a.kt)("li",{parentName:"ul"},"Press and a hold the front-panel button (left side of the ",(0,a.kt)("em",{parentName:"li"},"Quarto"),") for ","~","5 seconds. The blue power LED should turn off. Then release the button and press the button again for ","~","2 seconds the blue LED should turn back on and the device will boot up",(0,a.kt)("sup",{parentName:"li",id:"fnref-rebootbutton"},(0,a.kt)("a",{parentName:"sup",href:"#fn-rebootbutton",className:"footnote-ref"},"1")),".")),(0,a.kt)("p",null,"When the unit reboots, it will go into the bootloader and the status LED will flash white for ~3 seconds. After this period, the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," will try to load the application code. If you do not want this to happen (as this was the application code that crashed the ",(0,a.kt)("em",{parentName:"p"},"Quarto"),"), press the front-panel button once while the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," is in the bootloader (it is flashing the status LED white) and the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," will stay indefinitely in the bootloader.  When the button is pressed, the status LED will change to flashing red instead of white. You can now load a different application code (The crash report will not survive the power cycle)."),(0,a.kt)("p",null,"This is happens, please contact us via the ",(0,a.kt)("a",{parentName:"p",href:"https://forum.qnimble.com"},"forum")," or our ",(0,a.kt)("a",{parentName:"p",href:"/Contact"},"contact us")," link so we can try to improve the ",(0,a.kt)("em",{parentName:"p"},"Quarto"),"'s ability to reboot after a crash. If you can send us your code, that will make troubleshooting the issue much easier."),(0,a.kt)("h2",{id:"fixing-a-timeout-crash"},"Fixing a Timeout Crash"),(0,a.kt)("p",null,"Here's an example for code that will cause a timeout crash the ",(0,a.kt)("em",{parentName:"p"},"Quarto"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="Code that will crash the Quarto"',title:'"Code',that:!0,will:!0,crash:!0,the:!0,'Quarto"':!0},"void setup(void) {  \n  configureADC(1,1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n}\n\nvoid getADC1(void) {\n  double newdata = readADC1_from_ISR(); //read ADC voltage\n  writeDAC(1,newdata);\n  Serial.println(newdata);\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Serial.println()")," function is a relatively slow function as it converts raw data to ASCII and has to send that down over USB. It isn't fast enough to complete in under a 1\u03bcs. The solution to keep slow functions like Serial.print() out of high priority interrupts. One approach is to move the printing of the ADC data to the main loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="Solution A (Main Loop)"',title:'"Solution',A:!0,"(Main":!0,'Loop)"':!0},"volatile double adcdata;\n\nvoid setup(void) {  \n  configureADC(1,1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n}\n\nvoid getADC1(void) {\n  adcdata = readADC1_from_ISR(); //read ADC voltage\n  writeDAC(1,adcdata);\n}\n\nvoid loop() {\n    static unsigned long lastrun = 0;    \n    if (millis() > lastrun) { //Run once every 1000ms\n        lastrun = millis() + 1000;\n        toggleLEDGreen();\n        Serial.println(adcdata);\n      }\n}\n")),(0,a.kt)("p",null,"In the above example, the main loop is responsible for running the Serial.print() function, so it can get preempted by the ADC interrupt when necessary. While this example only prints the ADC data once per second, that isn't what is preventing the crash. If the loop were simply: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"void loop() {\n    Serial.println(adcdata);\n}\n")),(0,a.kt)("p",null,"the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," would not crash as the the USB (and ADC) interrupts can preempt the loop function, so no matter how long loop() takes to run, the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," can respond to USB and ADC data."),(0,a.kt)("p",null,"If you want to have more controlled timing than a simple loop can provide, we can use a timer. By default the timer runs with a low priority so it too will get interrupted by the ADC or the USB, and this will prevent the ",(0,a.kt)("em",{parentName:"p"},"Quarto")," from crashing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="Solution B (Timer)"',title:'"Solution',B:!0,'(Timer)"':!0},"volatile double adcdata;\nIntervalTimer printTimer;\n\nvoid setup(void) {  \n  configureADC(1,1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n  printTimer.begin(printData, 100); // run debug() every 100 microseconds\n}\n\nvoid getADC1(void) {\n  adcdata = readADC1_from_ISR(); //read ADC voltage\n  writeDAC1(adcdata);\n}\n\nvoid loop() {\n  static unsigned long lastrun = 0;    \n  if (millis() > lastrun) { //Run once every 1000ms\n      toggleLEDGreen();\n      lastrun = millis() + 1000;\n  }\n}\n\nvoid printData() {\n  Serial.println(adcdata);\n}\n")),(0,a.kt)("div",{className:"footnotes"},(0,a.kt)("hr",{parentName:"div"}),(0,a.kt)("ol",{parentName:"div"},(0,a.kt)("li",{parentName:"ol",id:"fn-rebootbutton"},"If you have an evaluation unit, then there are two buttons on the front panel, but only the button on the right (closest to the BNC connector) should be used. Additionally, the blue LED will not turn off when the ",(0,a.kt)("em",{parentName:"li"},"Quarto")," is powered down. After holding the button for >5 seconds, release the button and press it again for >2 seconds and the device should boot again.",(0,a.kt)("a",{parentName:"li",href:"#fnref-rebootbutton",className:"footnote-backref"},"\u21a9")))))}p.isMDXComponent=!0}}]);