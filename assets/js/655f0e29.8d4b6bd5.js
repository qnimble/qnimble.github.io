(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{175:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/arduino2-adc-config-s1-6e4178aed79cb86c850f9c4dd8fe88b0.png"},176:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/SimplePIDServo-s1-1893b5293796035a912ee97bed24e576.png"},80:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),i=n(7),o=(n(0),n(110)),r={slug:"Servo",id:"servo",sidebar_label:"PID Servo",title:"PID Servo"},l={unversionedId:"Examples/servo",id:"Examples/servo",isDocsHomePage:!1,title:"PID Servo",description:"The Quarto can turn into a proportional-integral-differential (PID) Servo with just 20 lines of code! Let's see how.",source:"@site/quarto/Examples/servo.md",slug:"/Examples/Servo",permalink:"/Quarto/Examples/Servo",version:"current",sidebar_label:"PID Servo",sidebar:"quarto_main_sidebar",previous:{title:"Frequently Asked Questions",permalink:"/Quarto/FAQ"}},c=[{value:"Setup",id:"setup",children:[]},{value:"Function when ADC Data is Available",id:"function-when-adc-data-is-available",children:[]},{value:"Final Code",id:"final-code",children:[]},{value:"Data",id:"data",children:[]}],s={toc:c};function d(e){var t=e.components,r=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The ",Object(o.b)("em",{parentName:"p"},"Quarto")," can turn into a proportional-integral-differential (PID) Servo with just 20 lines of code! Let's see how."),Object(o.b)("h2",{id:"setup"},"Setup"),Object(o.b)("p",null,"The setup function is run once at start-up and is used to configure the ADC. For the servo, we want use ADC channel 1, so we use the function configureADC1 to configure it. We want the  ADC to fire every 1\xb5s and to have a voltage range of \xb11.25V."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"void setup(void) {  \n  configureADC1(1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n}\n")),Object(o.b)("p",null,"With the Arduino 2.0 IDE, if we hover over the function configureADC1, a window pops up showing the function arguments:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"img",src:n(175).default})),Object(o.b)("p",null,"First argument, ",Object(o.b)("inlineCode",{parentName:"p"},"fire_every_us")," tells the ADC how often to fire. In this example, we want to run the ADC at its maximum rate of 1MSPS (1 Mega Samples Per Second) so we fire every 1us, so we set this parameter to one. If we wanted to sample every 5us (or 200 kHz sample rate), this should be set to 5."),Object(o.b)("p",null,"The second argument, ",Object(o.b)("inlineCode",{parentName:"p"},"fire_delay")," delays when the ADC fires. This has no real meaning when only using one ADC channel, but if you configure multiple ADC channels, to control the timing relationship between different channels. "),Object(o.b)("p",null,"The next argument, ",Object(o.b)("inlineCode",{parentName:"p"},"scale")," sets the ADC voltage range. Valid inputs are ",Object(o.b)("inlineCode",{parentName:"p"},"BIPOLAR_1250mV")," ",Object(o.b)("inlineCode",{parentName:"p"},"BIPOLAR_2500mV"),", ",Object(o.b)("inlineCode",{parentName:"p"},"BIPOLAR_5V")," and ",Object(o.b)("inlineCode",{parentName:"p"},"BIPOLAR_10V"),". In this case, we want the ADC range to be \xb11.25V, so we set it to ",Object(o.b)("inlineCode",{parentName:"p"},"BIPOLAR_1250mV")," ."),Object(o.b)("p",null,"Finally, the last argument, ",Object(o.b)("inlineCode",{parentName:"p"},"function")," is the function to call when there is ADC data. We will call this function ",Object(o.b)("inlineCode",{parentName:"p"},"getADC1")," although the name does not matter."),Object(o.b)("p",null,"We will also define a setpoint which is the target value we want to see at the ADC input. We will use a macro to do this so if we want to change the setpoint, we only have to change the value in one place. For this example, we will have the ",Object(o.b)("inlineCode",{parentName:"p"},"SETPOINT")," equal to 0.25"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"#define SETPOINT 0.25\n")),Object(o.b)("h2",{id:"function-when-adc-data-is-available"},"Function when ADC Data is Available"),Object(o.b)("p",null,"We now need to define the function that is called when the ADC gets data. On our case this function is called ",Object(o.b)("inlineCode",{parentName:"p"},"getADC"),". Here's the code for that function:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"void getADC1(void) {\n  static double integral = 0;\n  static double prev_adc = 0;\n  \n  double newadc = readADC1_from_ISR(); //read ADC voltage\n  \n  double prop = (newadc-SETPOINT) * 1.975; //proportional\n  integral += (newadc - SETPOINT) * 0.01; // integral gain\n  double diff = ( newadc - prev_adc) * 0.00001; // turn diff down for accuracate BW measurement\n  double newdac = prop + integral + diff;\n  \n  writeDAC1(-newdac); //invert for negative feedback  \n  prev_adc = newadc; //store new adc value for differential calculation\n}\n")),Object(o.b)("p",null,"The first two lines of the function define two double-precision floating point numbers ",Object(o.b)("inlineCode",{parentName:"p"},"integral")," and ",Object(o.b)("inlineCode",{parentName:"p"},"prev_adc"),". These two definitions start with static which means that these variables do not disappear after the function runs, but they are kept for subsequent runs. So for the first run, ",Object(o.b)("inlineCode",{parentName:"p"},"integral")," and ",Object(o.b)("inlineCode",{parentName:"p"},"prev_adc")," start at 0. If at the end of the first run, ",Object(o.b)("inlineCode",{parentName:"p"},"integral")," is 1.2345, then ",Object(o.b)("inlineCode",{parentName:"p"},"integral")," will start which that value for the next run, as so on."),Object(o.b)("p",null,"The next line reads the ADC1 value and stores into into the double ",Object(o.b)("inlineCode",{parentName:"p"},"newadc"),". "),Object(o.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(o.b)("div",{parentName:"div",className:"admonition-heading"},Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",{parentName:"h5",className:"admonition-icon"},Object(o.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},Object(o.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"Make sure to call readADCX_from_ISR()!!")),Object(o.b)("div",{parentName:"div",className:"admonition-content"},Object(o.b)("p",{parentName:"div"},"Any function that runs when new ADC data is available  must execute the function readADCX_from_ISR()!"))),Object(o.b)("p",null,"When the ADC has new data, it fires an interrupt. That interrupt executes the function configured in configureADCX and that function must clear the interrupt, which is done by running readADCX_from_ISR(). Otherwise the function will loop forever and the Quarto will crash. "),Object(o.b)("p",null,"The next set of commands calculate the proportional, integral and differential (PID) values. The proportional value is the difference between the ADC value (",Object(o.b)("inlineCode",{parentName:"p"},"newadc"),") and the SETPOINT, multiplied by a scale constant, in this case 1.975. The integral calculation is similar, but which is different scale constant (0.01) and we use a ",Object(o.b)("inlineCode",{parentName:"p"},"+=")," instead of a an ",Object(o.b)("inlineCode",{parentName:"p"},"=")," to assign it a value so it sums the new calculation with the previous value of ",Object(o.b)("inlineCode",{parentName:"p"},"integral"),". Next, the differential looks at the difference between the current ADC value (",Object(o.b)("inlineCode",{parentName:"p"},"newadc"),") and the previously measured ADC value (",Object(o.b)("inlineCode",{parentName:"p"},"prev_adc"),") and multiplies that by the scale constant (0.00001). Finally, we sum these two values together in the new value ",Object(o.b)("inlineCode",{parentName:"p"},"newdac"),"."),Object(o.b)("p",null,"The second to last line of the function writes the newly calculated PID value to the channel 1 DAC using the ",Object(o.b)("inlineCode",{parentName:"p"},"writeDAC1")," command. There is a minus sign in front of the argument ",Object(o.b)("inlineCode",{parentName:"p"},"newdac")," to invert the value, which we need to do to provide negative feedback. "),Object(o.b)("p",null,"The last line stores the most recent ADC measurement (",Object(o.b)("inlineCode",{parentName:"p"},"newadc"),") in the variable ",Object(o.b)("inlineCode",{parentName:"p"},"prev_adc")," for use the next time this function is run."),Object(o.b)("h2",{id:"final-code"},"Final Code"),Object(o.b)("p",null,"Putting this altogether, we have:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"#define SETPOINT 0.25\n\nvoid setup(void) {  \n  configureADC1(1,0,BIPOLAR_1250mV,getADC1); // Have ADC take measurement every 1us, \xb11.25V range\n}\n\nvoid getADC1(void) {\n  static double integral = 0;\n  static double prev_adc = 0;\n  \n  double newadc = readADC1_from_ISR(); //read ADC voltage\n  \n  double prop = (newadc-SETPOINT) * 1.975; //proportional\n  integral += (newadc - SETPOINT) * 0.01; // integral gain\n  double diff = ( newadc - prev_adc) * 0.00001; // turn diff down for accuracate BW measurement\n  double newdac = prop + integral + diff;\n  \n  writeDAC1(-newdac); //invert for negative feedback  \n  prev_adc = newadc; //store new adc value for differential calculation\n}\n")),Object(o.b)("h2",{id:"data"},"Data"),Object(o.b)("p",null,"Using this code, if you connect the channel 1 DAC output to the ADC channel 1 input, the Quarto can lock to itself and it will oscillate at over 100 kHz, as shown below. (Just lower the proportional gain scalar from 1.975 to stop the oscillation)"),Object(o.b)("p",null,Object(o.b)("img",{alt:"img",src:n(176).default})))}d.isMDXComponent=!0}}]);