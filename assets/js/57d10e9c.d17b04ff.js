(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{82:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(3),i=n(7),o=(n(0),n(110)),r={title:"Measuring Response Time",hide_title:!0},s={unversionedId:"AppNotes/MeasureLatency",id:"AppNotes/MeasureLatency",isDocsHomePage:!1,title:"Measuring Response Time",description:"Measuring Response Time (Latency & Jitter)",source:"@site/quarto/AppNotes/MeasureLatency.md",slug:"/AppNotes/MeasureLatency",permalink:"/Quarto/AppNotes/MeasureLatency",version:"current",sidebar:"quarto_main_sidebar",previous:{title:"Triggers",permalink:"/Quarto/Software/Triggers"}},l=[{value:"Overview",id:"overview",children:[]},{value:"Trigger Interrupt Latency",id:"trigger-interrupt-latency",children:[]},{value:"Latency Under Load",id:"latency-under-load",children:[]},{value:"Worst-Case Latency",id:"worst-case-latency",children:[]},{value:"Footnotes",id:"footnotes",children:[]}],c={toc:l};function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"measuring-response-time-latency--jitter"},"Measuring Response Time (Latency & Jitter)"),Object(o.b)("h2",{id:"overview"},"Overview"),Object(o.b)("p",null,"Whenever you want to MCU to stop what it is doing to handle something else, you use an interrupt to preempt the current task it is executing.  When new ADC data is ready, we use an interrupt to process that new data. Similarly when the USB has incoming data, it will use an interrupt so the MCU can handle the new USB data. Additionally, the ",Object(o.b)("em",{parentName:"p"},"Quarto")," can configure the trigger lines to act as interrupts so the user can externally interrupt the processor. "),Object(o.b)("p",null,"One of the key performance specifications of the ",Object(o.b)("em",{parentName:"p"},"Quarto")," is how fast it can respond an event (new data, an external trigger, etc). To measure this, we want to measure the time it takes for the MCU to respond to an interrupt (often called the interrupt latency).  Regardless of what causes of the trigger, the MCU must stop what it is doing and switch to running the function assigned the interrupt that fired. How long this takes depends on what the MCU was in middle of doing."),Object(o.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(o.b)("div",{parentName:"div",className:"admonition-heading"},Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",{parentName:"h5",className:"admonition-icon"},Object(o.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(o.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Interrupt Priority")),Object(o.b)("div",{parentName:"div",className:"admonition-content"},Object(o.b)("p",{parentName:"div"},"In this application note, we will assume that the interrupt we care about is running at the highest priority. If you have multiple interrupts firing then anything with a lower priority will have to wait for all the higher priority interrupts to complete before they can execute. Additionally, these lower-priority interrupts can have their execution paused while the MCU processes a higher priority interrupt."))),Object(o.b)("h2",{id:"trigger-interrupt-latency"},"Trigger Interrupt Latency"),Object(o.b)("p",null,"In this example, we will measure the interrupt latency from an external trigger, although the data would look the same for new ADC data as well. Here is basic code for responding to the rising edge on the Trigger 1 line."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"void setup() {  \n  setTrigger2Direction(PIN_DIRECTION_OUTPUT); // Use Trigger 2 as output\n  enableInterruptTrigger1(true, gotTrigger); // Run gotTrigger on Trigger 1 rising edge\n}\n\nvoid gotTrigger(void) {\n  setTrigger2High(); // Set Trigger 2 goes when know when function begins to run\n  delayNanoseconds(100); // Function runs too fast to see Trigger 2 pulse on O-scope otherwise\n  setTrigger2Low(); // Set Trigger 2 goes low when function completes\n}\n")),Object(o.b)("p",null,"An Oscilloscope is configured to display with 10s of persistence we we can see multiple takes on the same screen. The cyan trace shows Trigger 1 and yellow shows Trigger 2."),Object(o.b)("img",{className:"center",src:"/img/isr-latency-p1.png"}),Object(o.b)("p",null,"The Trigger 2 goes high about  110ns after the Trigger 1 goes high. So the Interrupt Latency is approximately 110ns. The ",Object(o.b)("inlineCode",{parentName:"p"},"gotTrigger()")," function finishes executing about 90ns later. Because of the persistence setup on the oscilloscope, the yellow trace is broadened by the timing jitter, as sometimes the response is a little faster or slower. But this is on the order of only 10ns. "),Object(o.b)("p",null,"While 110ns latency is terrific, this is under ideal circumstances. The ",Object(o.b)("em",{parentName:"p"},"Quarto")," is doing nothing besides waiting for the Trigger 1 interrupt to happen, so it does not have to stop what it is doing to respond. "),Object(o.b)("h2",{id:"latency-under-load"},"Latency Under Load"),Object(o.b)("p",null,"The previous code generated a nice baseline, however, the MCU was never doing anything except handling the Trigger 1 interrupt, so it was in an ideal position to respond quickly. Realistically, the MCU will be busy handling USB data and doing other tasks in the main loop. This will add jitter to the latency as sometimes the MCU is idle and sometimes it has to store what it is working to memory before it can respond to the interrupt. To model this better, we've added a new loop function that the MCU continuously runs. In the loop, we do a few things"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"USB: echo back any USB data that is received"),Object(o.b)("li",{parentName:"ul"},"Math: Do a math calculation all the time in the loop function"),Object(o.b)("li",{parentName:"ul"},"LED: Toggle the front panel LED every 500ms")),Object(o.b)("p",null,"The new code is:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"void setup() {  \n  setTrigger2Direction(PIN_DIRECTION_OUTPUT); // Use Trigger 2 as output\n  enableInterruptTrigger1(true, gotTrigger); // Run gotTrigger on Trigger 1 rising edge\n}\n\nvoid gotTrigger(void) {  \n  setTrigger2High(); // Set Trigger 2 goes when know when function begins to run\n  delayNanoseconds(100); // Function runs too fast to see Trigger 2 pulse on O-scope otherwise  \n  setTrigger2Low(); // Set Trigger 2 goes low when function completes\n}\n\nvoid loop() {\n  static unsigned long lastrun;\n  static signed long total;\n\n  if (millis() > lastrun + 500) { //Run once every 500ms            \n    toggleLEDGreen(); //toggle green LED;            \n    lastrun = lastrun + 500;\n  }\n\n  total += 324*(total-2343); //do some math in main loop\n\n  char dat;\n  while (Serial.available() > 0) {\n    dat = Serial.read(); //Read USB data if available\n    Serial.print(dat); //Echo data back over USB\n  }  \n}\n")),Object(o.b)("p",null,"An external function generator was used to have Trigger 1 go high at 1 MHz (once per 1\u03bcs) and a python script was used to stream data in and out of the ",Object(o.b)("em",{parentName:"p"},"Quarto")," (18 Mbps down, 18 Mbps up). While all this was happening, let's look at the response time again with the oscilloscope set at 10s persistence: "),Object(o.b)("img",{className:"center",src:"/img/isr-latency-p2.png"}),Object(o.b)("p",null,"The response it still usually about 110ns, however, over the 10 oscilloscope window we can see there are numerous events where the latency is higher. Especially when using the ",Object(o.b)("em",{parentName:"p"},"Quarto")," for servoing, just as important as the response time is how consistent that response time is. In the worst case Trigger 2 falls 275ns after the rising Trigger 1. That 275 ns includes the interrupt latency, the function execution time and the timing jitter.  With the minimal latency of 110ns and the function taking 100ns to run, the jitter is the remainder: 275ns - 110ns -90ns = 75ns. So the interrupt latency is bounded to be better than less than 200ns."),Object(o.b)("h2",{id:"worst-case-latency"},"Worst-Case Latency"),Object(o.b)("p",null,"There is another limitation on the latency that we haven't talked about and that is getting data into and out of the floating point unit (FPU). If the main process is doing floating point math (using ",Object(o.b)("inlineCode",{parentName:"p"},"floats")," or ",Object(o.b)("inlineCode",{parentName:"p"},"doubles")," in C), then it is using the FPU. If an interrupt fires that also needs to do floating point math, then, just like the MCU, the FPU needs to clean up and store what it is working on before it can process the new data. This adds jitter to the interrupt latency we measured previously. To test this, we will take our previous code and have both the main loop and the trigger interrupt do math on double precision floats. The new code is below."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c"},"void setup() {  \n  setTrigger2Direction(PIN_DIRECTION_OUTPUT); // Use Trigger 2 as output\n  enableInterruptTrigger1(true, gotTrigger); // Run gotTrigger on Trigger 1 rising edge\n}\ndouble DACout = 0; //global variable used by main loop and gotTrigger\n\nvoid gotTrigger(void) {  \n  setTrigger2High(); // Set Trigger 2 goes when know when function begins to run\n  writeDAC1(DACout*(DACout*2.342-3.232)); //Do some floating point math and then update the DAC with the result\n  delayNanoseconds(100); // Function runs too fast to see Trigger 2 pulse on O-scope otherwise  \n  setTrigger2Low(); // Set Trigger 2 goes low when function completes\n}\n\nvoid loop() {\n  static unsigned long lastrun;\n  static signed long total;\n\n  if (millis() > lastrun + 500) { //Run once every 500ms            \n    toggleLEDGreen(); //toggle green LED;            \n    lastrun = lastrun + 500;\n  }\n\n  DACout += 3.2342*sin(DACout*23.234+65.324); //do some FPU math in main loop\n\n  char dat;\n  while (Serial.available() > 0) {\n    dat = Serial.read(); //Read USB data if available\n    Serial.print(dat); //Echo data back over USB\n  }  \n}\n")),Object(o.b)("p",null,"In summary, the ",Object(o.b)("em",{parentName:"p"},"Quarto")," is doing the following:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Every 1\u03bcs, handle external trigger and do floating point math"),Object(o.b)("li",{parentName:"ul"},"Run floating point math in main loop all the time"),Object(o.b)("li",{parentName:"ul"},"Receive USB data at 15 Mbps"),Object(o.b)("li",{parentName:"ul"},"Transmit USB data at 15 Mbps")),Object(o.b)("p",null,"In this setup, we get the following latency measurement:"),Object(o.b)("img",{className:"center",src:"/img/isr-latency-p3.png"}),Object(o.b)("p",null,"The interrupt latency is now rarely at 110ns, but usually closer to 125ns. However, the worst case latency is 210ns. So the maximum jitter went up to from 75ns to 100ns. Additionally, the ",Object(o.b)("inlineCode",{parentName:"p"},"gotTrigger")," function now takes 160ns as it is doing math and updating the DAC in addition to the 100ns delay we programmed in. The ",Object(o.b)("inlineCode",{parentName:"p"},"gotTrigger")," function sometimes can finish as late as 370ns after the trigger fired, which is consistent with 110ns latency + 100 ns jitter + 160ns execution time.  Even when pushing the ",Object(o.b)("em",{parentName:"p"},"Quarto")," to its limits, the the interrupt latency is bounded to be under 210ns."),Object(o.b)("p",null,"For a 100 kHz PID Servo, the total loop delay is 5us (180\xb0 phase shift at 100kHz),  so 100ns of timing jitter is only 2% timing variation, a small effect. Having consistent and bounded interrupt latency is crucial for consistent loop bandwidths and response times."),Object(o.b)("h2",{id:"footnotes"},"Footnotes"),Object(o.b)("p",null,"To generate the data presented above, the following python script was used to stream data to and from the ",Object(o.b)("em",{parentName:"p"},"Quarto"),":"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-python"},"import serial,time,os\nser = serial.Serial('COM4')\npackets = 400\nloops = 200\npacketSizeSend = 64*64 \npacketSizeReceive = packetSizeSend\n\nloop=0\nfor empty in range(loops):\n    loop = loop + 1\n    start=time.time()\n    for i in range(packets):\n        byte = os.urandom(packetSizeSend)\n        ser.write(byte)\n        data=ser.read(packetSizeReceive)\n\n        if byte != data:\n            print('Error: Return data does not match. Length = {} and {}'.format(len(byte),len(data)))\n\n    stop=time.time()\n    rescaleSend = 8*packetSizeSend*packets/1000000.0/max(.000001,(stop-start))\n    rescaleReceive = 8*packetSizeReceive*packets/1000000.0/max(.000001,(stop-start))\n    print('Send Rate: {:0.2f} MBaud, Receive Rate: {:0.2f} MBaud. Got {} kBytes and received {} kBytes in {:0.2f} ms (Loop {}/{})'.format(rescaleSend,rescaleReceive,packets*packetSizeSend/1000,packets*packetSizeReceive/1000,(stop-start)*1000,loop,loops))\ndel ser\n")),Object(o.b)("p",null,"Running the script with the ",Object(o.b)("em",{parentName:"p"},"Quarto")," running the code from the ",Object(o.b)("a",{parentName:"p",href:"#worst-case-latency"},"Worst-Case Latency")," section outputs:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"...\nSend Rate: 15.79 MBaud, Receive Rate: 15.79 MBaud. Got 1638.4 kBytes and received 1638.4 kBytes in 830.08 ms (Loop 196/200)\nSend Rate: 15.56 MBaud, Receive Rate: 15.56 MBaud. Got 1638.4 kBytes and received 1638.4 kBytes in 842.31 ms (Loop 197/200)\nSend Rate: 15.46 MBaud, Receive Rate: 15.46 MBaud. Got 1638.4 kBytes and received 1638.4 kBytes in 847.92 ms (Loop 198/200)\nSend Rate: 15.68 MBaud, Receive Rate: 15.68 MBaud. Got 1638.4 kBytes and received 1638.4 kBytes in 835.76 ms (Loop 199/200)\nSend Rate: 15.67 MBaud, Receive Rate: 15.67 MBaud. Got 1638.4 kBytes and received 1638.4 kBytes in 836.39 ms (Loop 200/200)\n")))}p.isMDXComponent=!0}}]);