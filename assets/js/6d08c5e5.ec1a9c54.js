"use strict";(self.webpackChunkdoc_source=self.webpackChunkdoc_source||[]).push([[2880],{3266:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>T,frontMatter:()=>s,metadata:()=>h,toc:()=>c});var a=n(7462),i=n(7294),o=n(3905),r=n(614);i.Component;class l extends i.Component{constructor(e){super(e),this.title=e.title||"Click for the full code",this.language=e.language||"language-cpp"}render(){return i.createElement("details",null,i.createElement("summary",null,this.title),i.createElement(r.Z,{className:this.language},this.props.children[1]))}}const s={id:"Threads",slug:"Threads",title:"Threading: Run Multiple Functions at Once",sidebar_label:"Threading",sidebar_position:40,toc_max_heading_level:2,keywords:["Threads","protoThreads","Multiple Functions","Same Time","Parallel"],description:"Example for running multiple functions at the same time and controling their timing."},p=void 0,h={unversionedId:"Examples/Threads",id:"Examples/Threads",title:"Threading: Run Multiple Functions at Once",description:"Example for running multiple functions at the same time and controling their timing.",source:"@site/Quarto/Examples/Threads.mdx",sourceDirName:"Examples",slug:"/Examples/Threads",permalink:"/Quarto/Examples/Threads",draft:!1,tags:[],version:"current",sidebarPosition:40,frontMatter:{id:"Threads",slug:"Threads",title:"Threading: Run Multiple Functions at Once",sidebar_label:"Threading",sidebar_position:40,toc_max_heading_level:2,keywords:["Threads","protoThreads","Multiple Functions","Same Time","Parallel"],description:"Example for running multiple functions at the same time and controling their timing."},sidebar:"autoSideBar",previous:{title:"SD Card",permalink:"/Quarto/Examples/SDCard"},next:{title:"Serial Commands",permalink:"/Quarto/Examples/Commands"}},d={},c=[{value:"Writing Threaded Functions",id:"writing-threaded-functions",level:2},{value:"Example 1: Two Blinking Lights",id:"example-1-two-blinking-lights",level:2},{value:"Example 2: Run Slow Function And Blink the LED",id:"example-2-run-slow-function-and-blink-the-led",level:2},{value:"Example 3: Restarting a Completed Thread",id:"example-3-restarting-a-completed-thread",level:2},{value:"Example 4: Threads Calling Threads",id:"example-4-threads-calling-threads",level:2},{value:"protoThreads vs Interrupts",id:"protothreads-vs-interrupts",level:2},{value:"Interrupt-based timing has some distinct advances:",id:"interrupt-based-timing-has-some-distinct-advances",level:3},{value:"protoThread-based timing has some distinct advantages:",id:"protothread-based-timing-has-some-distinct-advantages",level:3},{value:"Final Thoughts",id:"final-thoughts",level:2}],u={toc:c},m="wrapper";function T(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Threading refers to running multiple code blocks, or threads, at the same time. In the context of the ",(0,o.kt)("em",{parentName:"p"},"Quarto"),", it is about running multiple functions in parallel (as opposed to sequentially) and controlling when those functions run. While the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," hardware can only execute one instruction at a time, by pausing the execution of one function to run another function, we can give the appearance of running multiple functions at the same time.  "),(0,o.kt)("p",null,"To program such behavior, we will utilize the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/qnimble/arduino-qprotothreads"},"qNimble variant")," of the ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/airbornemint/arduino-protothreads"},"protoThreads")," library."),(0,o.kt)("h2",{id:"writing-threaded-functions"},"Writing Threaded Functions"),(0,o.kt)("p",null,"To write a function that can be threaded with ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/airbornemint/arduino-protothreads"},"protoThreads"),", we have to make a few changes to the function:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Wrap the function name and arguments around ",(0,o.kt)("inlineCode",{parentName:"li"},"PT_THREAD(...)")),(0,o.kt)("li",{parentName:"ol"},"Begin the function with ",(0,o.kt)("inlineCode",{parentName:"li"},"PT_FUNC_START(pt)")),(0,o.kt)("li",{parentName:"ol"},"Add calls to protoThreads functions that enable the main function to pause its execution. These functions include:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PT_SLEEP()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PT_YIELD()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PT_WAIT_UNTIL()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PT_WAIT_WHILE()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PT_WAIT_THREAD()")))),(0,o.kt)("li",{parentName:"ol"},"Look for any variables whose value is stored across any of the above functions and, if so, add the word ",(0,o.kt)("inlineCode",{parentName:"li"},"static")," to their declaration"),(0,o.kt)("li",{parentName:"ol"},"End the function with ",(0,o.kt)("inlineCode",{parentName:"li"},"PT_FUNC_END(pt)"))),(0,o.kt)("p",null,"Once we have the threaded function, we can call it with the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SCHEDULE()")," function. Typically this is put in the ",(0,o.kt)("inlineCode",{parentName:"p"},"loop()")," function to cause the function to run continuously. Finally, we need to include the protoThreads library to the sketch by adding the line:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <protothreads.h>\n")),(0,o.kt)("h2",{id:"example-1-two-blinking-lights"},"Example 1: Two Blinking Lights"),(0,o.kt)("p",null,"The above instructions will make a lot more sense in the context of an example. For this example, we want to toggle two different LED's at different rates: the red LED at 1 Hz, and the blue red at 1.1Hz. Essentially, we want to run the following two functions independently: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void blinkRed(void) {\n    while(true) {\n        toggleLEDRed();\n        delay(500); //wait 500ms\n    }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void blinkBlue(void) {\n    while(true) {\n        toggleLEDBlue();\n        delay(450); //wait 450ms\n    }\n}\n")),(0,o.kt)("p",null,"Both these functions will run forever as we want to blink our LEDs forever. However, if you run either function on the ",(0,o.kt)("em",{parentName:"p"},"Quarto"),", it would run that function forever and never run the other function. Note, that this functionality could be achieved with interrupts, see the section ",(0,o.kt)("a",{parentName:"p",href:"#protothreads-vs-interrupts"},"interrupts vs threads")," for a discussion of pros and cons of interrupts and threads). To transform the above functions into thread functions, we first follow step #1 and replace "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void blinkRed(void) {\n")),(0,o.kt)("p",null,"with "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_THREAD(blinkRed(void)) {\n")),(0,o.kt)("p",null,"For step #2, we add ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START()")," as the first line in the function. So now we have:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_THREAD(blinkRed(void)) {\n  PT_FUNC_START(pt);\n      \n  // Loop forever\n  while(true) {\n    toggleLEDRed();\n    delay(500); //wait 500ms\n  }\n}\n")),(0,o.kt)("p",null,"Step #3 replaces the delay function with ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP()"),", a function that basically does the same thing as delay except that it lets the Quarto run other functions while its waiting for the required delay to occur. This example uses no variables, so step #4 does not apply. Lastly we add ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_END(pt)")," to the end of the function and now we have:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_THREAD(blinkRed(void)) {\n  PT_FUNC_START(pt);\n  // Loop forever\n  while(true) {\n    toggleLEDRed();\n    PT_SLEEP(pt, 500);\n  }\n\n  PT_FUNC_END(pt);\n}\n")),(0,o.kt)("p",null,"The function doesn't look that different, and it appears as if it too will loop forever and not allow another function to run. However, the trick is that the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," function will actually exit the function if enough time hasn't elapsed. And when the function is run again, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START")," function will jump ahead (over) to where the function previously left off and run ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," again.  With this new function, we can now run both functions (threads) in the main loop with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void loop() {\n  // Run the two threads\n  PT_SCHEDULE(blinkRed());\n  PT_SCHEDULE(blinkBlue());\n}\n")),(0,o.kt)("p",null,"What's happening is that ",(0,o.kt)("inlineCode",{parentName:"p"},"loop")," runs ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkRed")," and when ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkRed")," hits the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," it will exit and then ",(0,o.kt)("inlineCode",{parentName:"p"},"loop")," will run ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkBlue"),". If not enough time has elapsed for ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkBlue"),", it will return without running ",(0,o.kt)("inlineCode",{parentName:"p"},"toggleBlue")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"loop")," will then try ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkRed"),", which will also return without running ",(0,o.kt)("inlineCode",{parentName:"p"},"toggleRed")," if not enough time has elapsed. This will continue until the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," in one of the functions has been met, in which case the function execution will proceed, the LED will toggle and then it will hit ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," again and the exit as it again needs to wait for enough time to have passed. Both loops can now execute at their own speed and if you watch the ",(0,o.kt)("em",{parentName:"p"},"Quarto"),", sometimes the red LED will stay on for (nearly) half a second while the blue is off and sometimes the red will barely blink without the blue LED on. The timing between when the LED's turn on is constantly changing because the blue loop is running a bit faster than the red loop. "),(0,o.kt)("admonition",{title:"Note for Advanced Users",type:"important"},(0,o.kt)("p",{parentName:"admonition"},"If you are used to c / c++ syntax, the syntax around the PT functions may look a little odd. The reason for this is that protoThreads is written entirely in macros using the preprocessor. When these macros are expanded they produce clean, normal c/c++ code, but before that substitution you have macro functions like the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_THREAD")," wrapper that look a little strange.")),(0,o.kt)("p",null,"While the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," is only executing one command at a time, by jumping back and forth between the two functions, it can mimic the behavior of independently running  multiple functions at the same time. "),(0,o.kt)(l,{title:"Click here for the full code",mdxType:"HideCode"}," ","#include <protothreads.h>\n\nPT_THREAD(blinkRed(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    PT_SLEEP(pt, 500);\n    toggleLEDRed();\n  }\n  PT_FUNC_END(pt);\n}\nPT_THREAD(blinkBlue(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    PT_SLEEP(pt, 450);\n    toggleLEDBlue();\n  }\n  PT_FUNC_END(pt);\n}\n// the main loop runs forever and runs the threads as needed\nvoid loop() {\n  // Run the two threads\n  PT_SCHEDULE(blinkRed());\n  PT_SCHEDULE(blinkBlue());\n}\n"),(0,o.kt)("h2",{id:"example-2-run-slow-function-and-blink-the-led"},"Example 2: Run Slow Function And Blink the LED"),(0,o.kt)("p",null,"The previous example showed two slow or infrequent loops running, but what if we want our main function that is processing data to run quickly but we will still want an LED to blink while its processing the data. In this case, let's have the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," blink red every 500ms while the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," is processing some data, but then change to blinking green once the processing is done. "),(0,o.kt)("p",null,"For the function that blinks the LED, it will look very similar to the previous example, except we will query if the processData thread has completed to determine the LED color to blink:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_THREAD(blinkLED(void)) {\n  PT_FUNC_START(pt);\n\n  while(true) {\n    PT_SLEEP(pt, 500);\n    if (PT_SCHEDULE(processData())) {\n      setLED(1,0,0); //turn on RED LED\n    } else {\n      setLED(0,1,0); //turn on Green LED\n    }\n    PT_SLEEP(pt, 500);\n    setLED(0,0,0); //turn off LEDs\n  }\n\n  PT_FUNC_END(pt);\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SCHEDULE")," function returns 0 if the function returned early (from ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," and the like), and 1 if got to the end, so we can use that to query if the function has completed. "),(0,o.kt)("p",null,"As an example, for the data processing function, we will do the following slow calculation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"processData(void) {\n  double calc = 1.234;\n  for(uint i=0; i< 50000000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n  }\n}\n")),(0,o.kt)("p",null,"The first step is to convert the ",(0,o.kt)("inlineCode",{parentName:"p"},"processData")," function into a protoThread function. Most of what we did previously with the ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkRed")," example will apply here. In ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkRed"),", the function ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," did two things: it both paused the execution of the thread and it let the function pause to go execute other threads. Here, we need only that latter functionality, and we can accomplish it with the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," function. That function yields control over execution once so other threads can run and then resumes from where it left off.  With those changes we have:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"showLineNumbers",showLineNumbers:!0},'PT_THREAD(processData(void)) {\n  PT_FUNC_START(pt);\n  double calc = 1.234;\n  for(uint i=0; i< 5000000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n    PT_YIELD(pt); // pause here to check if other threads need to be run\n  }\n    \n  Serial.printf("Result of calculation is %f\\n",calc);\n  PT_FUNC_END(pt);\n}\n')),(0,o.kt)("p",null,"If you compile this function, you will get warnings about variables being used without be initialized. The reason for this is that if you run the function the first time, it will start at ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START()")," on line 2 and execute up to ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," on line 7. But then ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," will cause the function to exit. When the thread is run again, ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START")," will cause it to jump ahead to where it was previously, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," on line 7. This means that the code is jumping over the initialization of both the ",(0,o.kt)("inlineCode",{parentName:"p"},"double calc")," variable (line 3) and the ",(0,o.kt)("inlineCode",{parentName:"p"},"uint i")," variable (line 4).  If you are paying attention to compiler warnings (and you should be), you'll notice its telling you about this problem:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-none"},"ProcessData.ino:3:10: warning: 'calc' may be used uninitialized in this function [-Wmaybe-uninitialized]\n   30 |   double calc = 1.234;\n      |          ^~~~\n")),(0,o.kt)("p",null,"The solution to this in step #4 from the ",(0,o.kt)("a",{parentName:"p",href:"#writing-threaded-functions"},"Writing Threaded Functions")," section. By declaring these variables as static, they retain their value across multiple calls of the threaded function and do not need to get initialized every time the function runs. Note that the variable temp does not need to be static because its value always gets set before being used. This is because if ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START")," jumps to the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," location, it skips the temp initialization, but it then goes to the top of the for loop (where it reads the variable ",(0,o.kt)("inlineCode",{parentName:"p"},"i"),") and then it initializes temp. If we put the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," between lines 5 and 6, then we would need to declare temp as a static variable as it could be accessed after ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," and before getting initialized. With these changes, the function is now:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"showLineNumbers",showLineNumbers:!0},'PT_THREAD(processData(void)) {\n  PT_FUNC_START(pt);\n  static double calc = 1.234;\n  for(static uint i=0; i< 5000000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n    PT_YIELD(pt); // pause here to check if other threads need to be run\n  }\n    \n  Serial.printf("Result of calculation is %f\\n",calc);\n  PT_FUNC_END(pt);\n}\n')),(0,o.kt)(l,{title:"Click here for the full code",mdxType:"HideCode"}," ",'#include <protothreads.h>\n\nPT_THREAD(blinkLED(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    PT_SLEEP(pt, 500);\n    if (PT_SCHEDULE(processData())) {      \n      setLED(1,0,0); //turn on RED LED\n    } else {\n      setLED(0,1,0); //turn on Green LED\n    }\n    PT_SLEEP(pt, 500);\n    setLED(0,0,0); //turn off LEDs\n  }\n  PT_FUNC_END(pt);\n}\n\nPT_THREAD(processData(void)) {\n  PT_FUNC_START(pt);\n  static double calc = 1.234;\n  for(static uint i=0; i< 5000000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n    PT_YIELD(pt); // pause here to check if other threads need to be run\n  }\n   \n  Serial.printf("Result of calculation is %f\\n",calc);\n  PT_FUNC_END(pt);\n}\n\nvoid loop() {\n  // Run the two threads\n  PT_SCHEDULE(processData());  \n  PT_SCHEDULE(blinkLED());\n}\n'),(0,o.kt)("h2",{id:"example-3-restarting-a-completed-thread"},"Example 3: Restarting a Completed Thread"),(0,o.kt)("p",null,"In ",(0,o.kt)("a",{parentName:"p",href:"#example-2-run-slow-function-and-blink-the-led"},"example #2"),", once the processData thread completes, it never runs again. If, however, we wanted to re-run a thread that has completed, we can do that with the function ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_RESTART"),". However, to do that ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_RESTART")," needs the (pointer to the) pt object that stores the thread's internal state and in the above examples that object is not exposed outside of the thread itself. So we'll have to change the structure a bit to create the ",(0,o.kt)("inlineCode",{parentName:"p"},"pt")," object outside the function so we have access to it in other functions. First we create that ",(0,o.kt)("inlineCode",{parentName:"p"},"pt")," object and a pointer to it as globals by instantiating them outside of any function with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"pt ptProcessData = {0};\npt* ptProcess = &ptProcessData;\n")),(0,o.kt)("p",null,"Then when we create the processThread function, we will start it with ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START_EXT(ptProcess)")," instead of the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START(pt)"),". Other PT functions like ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_END")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP"),", etc will take ",(0,o.kt)("inlineCode",{parentName:"p"},"ptProcess"),", the pointer to the global object as the argument instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"pt"),", which typically is created (locally) by the ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_FUNC_START")," function. So now we have"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_THREAD(processData(void)) {\n  PT_FUNC_START_EXT(ptProcess);\n\n  static double calc = 0.1234;\n  static uint i=0;\n\n  for(i=0; i< 2500000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n    PT_YIELD(ptProcess); *// pause here to check if other threads need to be run*\n  }\n  PT_FUNC_END(ptProcess);\n}\n")),(0,o.kt)("p",null,"Finally, we will create a new thread which waits for the processData thread to finish, then waits 10 seconds and then restarts the processData thread. Here's how that function is written:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_THREAD(reProcess(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    PT_WAIT_THREAD(pt,processData()); //wait until processData thread completes\n    PT_SLEEP(pt,10000); //wait 10s after processData is done\n    PT_RESTART(ptProcess); //Restart the finished thread\n  }\n  PT_FUNC_END(pt);\n}\n")),(0,o.kt)("p",null,"Putting that all together, the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," will blink red while it is processing data, then it will wait for 10 seconds while blinking green and then it will start processing data again and blink red, and repeat that pattern indefintely."),(0,o.kt)(l,{title:"Click here for the full code",mdxType:"HideCode"}," ","#include <protothreads.h>\n\npt ptProcessData = {0};\npt* ptProcess = &ptProcessData;\n\nPT_THREAD(blinkLED(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    PT_SLEEP(pt, 500);\n    if (PT_SCHEDULE(processData())) {\n      setLED(1,0,0); //turn on RED LED\n    } else {\n      setLED(0,1,0); //turn on Green LED\n    }\n    PT_SLEEP(pt, 500);\n    setLED(0,0,0); //turn off LEDs\n  }\n  PT_FUNC_END(pt);\n}\n\nPT_THREAD(reProcess(void)) {\n  PT_FUNC_START(pt);\n\n  while(true) {\n    PT_SPAWN(pt,ptProcess,processData()); // go process data\n    PT_SLEEP(pt,10000); //wait 10s after processData is done\n  }\n  PT_FUNC_END(pt);\n}\n\nPT_THREAD(processData(void)) {\n  PT_FUNC_START_EXT(ptProcess);\n\n  static double calc = 0.1234;\n  static uint i=0;\n\n  for(i=0; i< 2500000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n    PT_YIELD(ptProcess); // pause here to check if other threads need to be run\n  }\n\n  PT_FUNC_END(ptProcess);\n}\n\nvoid loop() {\n  PT_SCHEDULE(reProcess());\n  PT_SCHEDULE(blinkLED());\n}\n"),(0,o.kt)("h2",{id:"example-4-threads-calling-threads"},"Example 4: Threads Calling Threads"),(0,o.kt)("p",null,"Finally, we can have threads call (or spawn) other threads. In this example, we will reproduce the behavior of ",(0,o.kt)("a",{parentName:"p",href:"#example-3-restarting-a-completed-thread"},"example #3")," but instead of having the main loop run three threads (",(0,o.kt)("inlineCode",{parentName:"p"},"blinkLED"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"processData"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"reProcess"),"), we need only two: ",(0,o.kt)("inlineCode",{parentName:"p"},"blinkLED")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"reProcess")," and that second thread will spawn the other thread, ",(0,o.kt)("inlineCode",{parentName:"p"},"processData"),". So instead restarting the ",(0,o.kt)("inlineCode",{parentName:"p"},"processData")," thread that runs in ",(0,o.kt)("inlineCode",{parentName:"p"},"loop"),",  we simply spawn it as needed from another thread. The command to run a new thread is "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"PT_SPAWN(pt,thread_pt,thread(args));\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"pt")," is the (pointer to the) pt object of the current thread. ",(0,o.kt)("inlineCode",{parentName:"p"},"thread_pt")," is the (pointer to the) pt object for the thread we are going to run, so as in ",(0,o.kt)("a",{parentName:"p",href:"#example-3-restarting-a-completed-thread"},"example #3"),", that object will need to be defined externally. Finally, the last argument is the threaded function itself, including any arguments we are passing to it. "),(0,o.kt)("p",null,"Now we can slightly alter the reProcess thread to run ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SPAWN")," and not ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_WAIT_THREAD")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_RESTART")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"{5}","{5}":!0},"PT_THREAD(reProcess(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    //PT_WAIT_THREAD(pt,processData()); //replaced with PT_SPAWN\n    PT_SPAWN(pt,ptProcess,processData());\n    PT_SLEEP(pt,10000); //wait 10s after processData is done\n    //PT_RESTART(ptProcess); //also repalced by PT_SPAWN\n  }\n  PT_FUNC_END(pt);\n}\n")),(0,o.kt)("p",null,"Finally, we can remove processData from the main loop as it now gets called on demand, instead of being restarted."),(0,o.kt)(l,{title:"Click here for the full code",mdxType:"HideCode"}," ","#include <protothreads.h>\n\npt ptProcessData = {0};\npt* ptProcess = &ptProcessData;\n\nPT_THREAD(blinkLED(void)) {\n  PT_FUNC_START(pt);\n  while(true) {\n    PT_SLEEP(pt, 500);\n    if (PT_SCHEDULE(processData())) {\n      setLED(1,0,0); //turn on RED LED\n    } else {\n      setLED(0,1,0); //turn on Green LED\n    }\n    PT_SLEEP(pt, 500);\n    setLED(0,0,0); //turn off LEDs\n  }\n  PT_FUNC_END(pt);\n}\n\nPT_THREAD(reProcess(void)) {\n  PT_FUNC_START(pt);\n\n  while(true) {\n    PT_WAIT_THREAD(pt,processData()); //wait until processData thread completes\n    PT_SLEEP(pt,10000); //wait 10s after processData is done\n    PT_RESTART(ptProcess); //Restart the finished thread\n  }\n  PT_FUNC_END(pt);\n}\n\nPT_THREAD(processData(void)) {\n  PT_FUNC_START_EXT(ptProcess);\n\n  static double calc = 0.1234;\n  static uint i=0;\n\n  for(i=0; i< 2500000;i++) {\n    double temp = cos(calc*(calc-1.23*i));\n    calc = temp*sin((calc-0.23*i)*3.456)+calc*calc/9.8765;\n    PT_YIELD(ptProcess); // pause here to check if other threads need to be run\n  }\n\n  PT_FUNC_END(ptProcess);\n}\n\nvoid loop() {\n  // Run the two threads\n  PT_SCHEDULE(processData());  \n  PT_SCHEDULE(blinkLED());\n}\n"),(0,o.kt)("h2",{id:"protothreads-vs-interrupts"},"protoThreads vs Interrupts"),(0,o.kt)("p",null,"You may have noticed that all of these examples could have been accomplished by having the LED blinking controlled by a function that runs via a Internal Timer interrupt (see the ",(0,o.kt)("a",{parentName:"p",href:"./Pulsed_Output"},"Arbitrary Output Waveform")," for an example). A simple couple lines of code could have a LED-toggling function run every 500ms:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"IntervalTimer LED_Toggle;\nvoid setup() {  \n  LED_Toggle.begin(runFunction,500000);\n}\n")),(0,o.kt)("p",null,"More generally, interrupts can be used instead of threads to allow jumping between different functions. Below we will look at some of the strengths of using interrupts instead of threads."),(0,o.kt)("h3",{id:"interrupt-based-timing-has-some-distinct-advances"},"Interrupt-based timing has some distinct advances:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Excellent Timing Precision"),(0,o.kt)("li",{parentName:"ul"},"No processing overhead except when interrupt fires"),(0,o.kt)("li",{parentName:"ul"},"No need for static (global) variables that are contained within function."),(0,o.kt)("li",{parentName:"ul"},"No software modifications needed to pause and restart execution of main loop")),(0,o.kt)("p",null,"Because the interrupt interrupts the processor, it can do so, for example, exactly every 500ms instead of the first time after 500ms that the processor happens to check if the thread needs to run. With protoThreads, this timing and delay jitter can be small (<1\xb5s) or arbitrarily large depending on how often your program gets to a ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_SLEEP")," function and how many threads you have running. Additionally, with protoThreads there is some processing overhead with constantly checking if other threads need to run. The lower the timing delay and jitter, the more often we are checking on the threads, the higher the overhead and visa-versa.  That said, checking on the status of threads typically takes about 200ns, so even processes that run for up to no more than 10\xb5s (thus 10\xb5s of timing jitter and delay if the other threads' delay is negligible ) run at 98% full processing power. By 1ms, that goes to 99.98%. "),(0,o.kt)("p",null,"Also with interrupts, the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," keeps the memory state of the function that gets interrupted, so there is no need to declare local variables as static like there is with protoThreads. In certain cases this can save significant memory. In fact no changes to the main loop need to be made to support an interrupt function unless that function needs to interact with the main code."),(0,o.kt)("h3",{id:"protothread-based-timing-has-some-distinct-advantages"},"protoThread-based timing has some distinct advantages:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Unlimited Number of protoThreads"),(0,o.kt)("li",{parentName:"ul"},"Can interrupt other interrupts"),(0,o.kt)("li",{parentName:"ul"},"More flexible prioritization, can runs multiple loops as fast as possible")),(0,o.kt)("p",null,"One limitation is that the ",(0,o.kt)("em",{parentName:"p"},"Quarto")," only supports 4 IntervalTimers running at the same time, while the number of protoThreads is not limited. Additionally, all IntervalTimer interrupts run at the same priority,  and they cannot interrupt each other. This means that if one interrupt is slow, it will block and delay the running of another interrupt, which can undermine the precise timing possible with InternalTimer interrupts. Additionally, with interval interrupts the only way to prioritize one interrupt over the other is to disable the one you don't want until the other on finishes. This can be done, but can get complicated while protoThreads has a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_WAIT_THREAD()")," function for one thread to wait until the other completes."),(0,o.kt)("p",null,"Also with protoThreads, by controlling where you place ",(0,o.kt)("inlineCode",{parentName:"p"},"PT_YIELD")," and the like, you control when a function gets pre-empted, which can be tricky with interrupts. If you have two threads interacting with the same data, this can be very helpful because you can guarantee that, say, a consumer of the data never runs while a different thread is in the middle of preparing that data."),(0,o.kt)("p",null,"Perhaps most importantly, you can have two or more threads running without delay with protoThreads, and yielding to other threads when they don't have work to. Reproducing that behavior with interrupts would be very challenging."),(0,o.kt)("h2",{id:"final-thoughts"},"Final Thoughts"),(0,o.kt)("p",null,"Hopefully these examples show how flexible and powerful protoThreads can be. You can have lots of different threads, some waiting on timers, others waiting on threads to complete, and others running as fast as they can. In general, IntervalTimers are great for very fast functions (toggle an LED, set a flag, etc) that need precise timing. But for functions with greater complexity, especially if these functions interact with each other, protoThreads can be a great way to move beyond running every function sequentially."))}T.isMDXComponent=!0}}]);