"use strict";(self.webpackChunkdoc_source=self.webpackChunkdoc_source||[]).push([[9482],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return m}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(a),m=o,h=p["".concat(s,".").concat(m)]||p[m]||c[m]||r;return a?n.createElement(h,i(i({ref:t},d),{},{components:a})):n.createElement(h,i({ref:t},d))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},388:function(e,t,a){a.d(t,{H2:function(){return r},Lc:function(){return i}});var n=a(1073),o=a(7294),r=function(e){var t=e.children;return o.createElement("div",{className:"baloo"},t)},i=function(e){var t=e.children;return o.createElement("div",{className:"baloo thick"},t)};o.Component},2365:function(e,t,a){a.d(t,{X2:function(){return r},Z6:function(){return l},h4:function(){return i},sg:function(){return o}});var n=a(7294),o=function(e){var t=e.children,a=e.width,o=void 0===a?"6":a,r=e.align,i=void 0===r?"left":r;return n.createElement("div",{className:"col col--"+o+" text--"+i},t)},r=function(e){var t=e.children;return n.createElement("div",{className:"row"},t)},i=function(e){var t=e.children;return n.createElement("h1",null,t)},l=function(e){var t=e.children;return n.createElement("div",{className:"specs"},t)}},7246:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return d},default:function(){return f},frontMatter:function(){return u},metadata:function(){return c},toc:function(){return m}});var n=a(3117),o=a(102),r=(a(7294),a(3905)),i=(a(4996),a(2365)),l=a(388),s=(a.p,["components"]),u={id:"Quarto",sidebar_position:1,slug:"/",sidebar_label:"Quarto",title:"qNimble Quarto A Digital Brain for the Analog World\u2122",hide_title:!0,hide_table_of_contents:!0,keywords:["DAC","ADC","data","acquisition","16bit","high-speed","speed","latency","servo","PID","PIID","filters","digital","analog","FPGA","NI","National Instruments","Alternative","DAQ","Data Acquisition","LabView","Lab View","FPGA","compactRIO","cRIO"],description:"qNimble Quarto is a high speed ADC DAC 16 bit analog to digital solution for filters, servos, PID loops and other applications."},d=void 0,c={unversionedId:"Quarto",id:"Quarto",title:"qNimble Quarto A Digital Brain for the Analog World\u2122",description:"qNimble Quarto is a high speed ADC DAC 16 bit analog to digital solution for filters, servos, PID loops and other applications.",source:"@site/Quarto/Quarto.md",sourceDirName:".",slug:"/",permalink:"/Quarto/",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"Quarto",sidebar_position:1,slug:"/",sidebar_label:"Quarto",title:"qNimble Quarto A Digital Brain for the Analog World\u2122",hide_title:!0,hide_table_of_contents:!0,keywords:["DAC","ADC","data","acquisition","16bit","high-speed","speed","latency","servo","PID","PIID","filters","digital","analog","FPGA","NI","National Instruments","Alternative","DAQ","Data Acquisition","LabView","Lab View","FPGA","compactRIO","cRIO"],description:"qNimble Quarto is a high speed ADC DAC 16 bit analog to digital solution for filters, servos, PID loops and other applications."},sidebar:"autoSideBar",next:{title:"Specifications",permalink:"/Quarto/Specifications"}},p={},m=[{value:"At a glance",id:"at-a-glance",level:2},{value:"How does the <em>qNimble Quarto</em> work?",id:"how-does-the-qnimble-quarto-work",level:2},{value:"How does the  <em>qNimble Quarto</em> compare to a...",id:"how-does-the--qnimble-quarto-compare-to-a",level:2},{value:"USB approach",id:"usb-approach",level:3},{value:"Traditional DAQ approach",id:"traditional-daq-approach",level:3},{value:"FPGA approach",id:"fpga-approach",level:3},{value:"Summary",id:"summary",level:2}],h={toc:m};function f(e){var t=e.components,u=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},h,u,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(i.h4,{mdxType:"Header"},(0,r.kt)(l.H2,{mdxType:"Brand"},"Quarto"),": A Digital Brain for the Analog World\u2122"),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Win a Free Quarto!")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"We are raffling off a free ",(0,r.kt)("em",{parentName:"p"},"Quarto"),"! But you can't win if you don't enter the ",(0,r.kt)("a",{parentName:"p",href:"/Raffle"},"Raffle"),"! (For full details, see the ",(0,r.kt)("a",{parentName:"p",href:"/RaffleTerms"},"Terms & Conditions"),".)"))),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"qNimble Quarto")," is a multi-function data acquisition platform that is easy to use, but incredibly powerful and capable of reading, processing and writing analog data in real-time. Low latency, 1 MSPS, 16 bit-ADC's and DAC's are directly accessible with an blazing-fast 500 MHz CPU dedicated to running your code.  The ",(0,r.kt)("em",{parentName:"p"},"Quarto")," is Arduino\u2122-compatible, so you can program it in the Arduino IDE, or your favorite C/C++ environment.  Designed for low-latency and simplicity, you can build a 100kHz bandwidth PID servo control system or custom digital filters with just a few lines of code. What will you build?"),(0,r.kt)("img",{className:"center",src:"/img/quarto-frontpanel.jpg"}),(0,r.kt)("h2",{id:"at-a-glance"},"At a glance"),(0,r.kt)(i.X2,{mdxType:"Row"},(0,r.kt)(i.sg,{mdxType:"Column"},(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Hardware")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"4 Analog Inputs (\xb110V, \xb15V, \xb12.5V, \xb11.25V @1MSPS, 16 bit)"),(0,r.kt)("li",{parentName:"ul"},"4 Analog Outputs (\xb110V, 1MSPS, 16 bit)"),(0,r.kt)("li",{parentName:"ul"},"500 MHz ARM M7 Processor"),(0,r.kt)("li",{parentName:"ul"},"8 GPIO pins, 2 Triggers"),(0,r.kt)("li",{parentName:"ul"},"32 MB RAM, 8 MB Flash"),(0,r.kt)("li",{parentName:"ul"},"SD Card Support",(0,r.kt)("sup",{parentName:"li",id:"fnref-sd_card"},(0,r.kt)("a",{parentName:"sup",href:"#fn-sd_card",className:"footnote-ref"},"1"))))),(0,r.kt)(i.sg,{mdxType:"Column"},(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Key Capabilities")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"100 kHz PID Servo"),(0,r.kt)("li",{parentName:"ul"},"<3\u03bcs latency from ADC read to DAC updating"),(0,r.kt)("li",{parentName:"ul"},"Floating-point math support"),(0,r.kt)("li",{parentName:"ul"},"Arduino\u2122 Compatible"),(0,r.kt)("li",{parentName:"ul"},"Open Source")))),(0,r.kt)("h2",{id:"how-does-the-qnimble-quarto-work"},"How does the ",(0,r.kt)("em",{parentName:"h2"},"qNimble Quarto")," work?"),(0,r.kt)(i.X2,{mdxType:"Row"},(0,r.kt)(i.sg,{mdxType:"Column"},(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",alt:"img",src:a(1008).Z,width:"512",height:"293"}))),(0,r.kt)(i.sg,{mdxType:"Column"},(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Quarto")," combines four high-speed, low-latency 16-bit DACs and ADCs with a powerful CPU and an FPGA. The FPGA handles all the communication with the DAC and ADC and we created InstaWrite\u2122 to enable the CPU to read from or write to the FPGA immediately. Communication with the ADC and DAC never slows down the CPU.  The entire signal chain is designed for low latency (~1\u03bcs) to support high-bandwidth servoing and filtering so you can respond to your data quickly. With hardware support for double-precision floating point math, you can do advanced math calculations on your data in real-time."))),(0,r.kt)("h2",{id:"how-does-the--qnimble-quarto-compare-to-a"},"How does the  ",(0,r.kt)("em",{parentName:"h2"},"qNimble Quarto")," compare to a..."),(0,r.kt)(i.X2,{mdxType:"Row"},(0,r.kt)(i.sg,{width:"1",mdxType:"Column"}),(0,r.kt)(i.sg,{width:"11",mdxType:"Column"},(0,r.kt)("h3",{id:"usb-approach"},"USB approach"),(0,r.kt)("p",null,"Data-acquisition over USB is simple and often inexpensive. While not universal, these solutions usually have 12-bit or fewer ADC's and DAC's and limited sample rates. But any USB approach will have very high latency and timing jitter. The USB protocol is designed for moderate latency or high throughput, but not both. The round trip time from the device, to your computer over USB and back again can be take many milliseconds. If you just want to generate a low-bandwidth analog output or stream analog data back to the device, this can be a great solution. But if you want to interact with your data quickly, you will need a different approach."))),(0,r.kt)(i.X2,{mdxType:"Row"},(0,r.kt)(i.sg,{width:"1",mdxType:"Column"}),(0,r.kt)(i.sg,{width:"11",mdxType:"Column"},(0,r.kt)("h3",{id:"traditional-daq-approach"},"Traditional DAQ approach"),(0,r.kt)("p",null," A traditional data-acquisition (DAQ) approach has dedicated hardware that either runs on your computer or on a dedicated chassis. Modern computers are amazing, but they are not designed for low-latency (~1us) response times. Even when running a Real-Time OS, getting predictable latency under 10us can be challenging. Additionally, the complexity of running a full operating system adds cost and complexity to these approaches. "))),(0,r.kt)(i.X2,{mdxType:"Row"},(0,r.kt)(i.sg,{width:"1",mdxType:"Column"}),(0,r.kt)(i.sg,{width:"11",mdxType:"Column"},(0,r.kt)("h3",{id:"fpga-approach"},"FPGA approach"),(0,r.kt)("p",null,"When you want the lowest latency connection to an ADC or a DAC, go with an FPGA. It can handle ADC data sampling at 100M samples per second and process the data in well under 100ns. But such power comes with a few drawbacks. In addition to the higher cost of an FPGA,  programming one has its own challenges:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Learning Curve")," -  Programming an FPGA is complex and takes a while to learn. Troubleshooting an FPGA is even harder."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Iteration Time")," -  Compile times on an FPGA can be tens of minutes or even hours. That really slows down how fast you can try and iterate your ideas."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Math")," -  Floating point math is very computationally expensive and usually calculations must be done with integers.")),(0,r.kt)("p",null,"If you aren't programming an FPGA, then you are using someone else's FPGA program. This solves many of the above issues, but these approaches tend to be expensive and limit you to the features and functionality they programmed into the FPGA."))),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"The Quarto approach gives you the speed and power of an FPGA without its complexity or expense. You can program your custom code in C++ with the easy-to-use Arduino\u2122 IDE without worrying about FPGA design or avoiding floating point math. Your code is running directly on the CPU (no OS) to maximize simplicity and speed."),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-sd_card"},"Requires hardware version 3.1 or higher. All ",(0,r.kt)("em",{parentName:"li"},"Quartos")," shipped after Febuarary 2022 support the SD card. To find out the hardware version of your ",(0,r.kt)("em",{parentName:"li"},"Quarto"),", please run the 'DeviceInfo' example under 'Testing'. The numbers after \"qN-101.\" in the Device ID is the hardware version. So \"qN-101.3.1\" is hardware version 3.1.",(0,r.kt)("a",{parentName:"li",href:"#fnref-sd_card",className:"footnote-backref"},"\u21a9")))))}f.isMDXComponent=!0},1008:function(e,t,a){t.Z=a.p+"assets/images/bnc-s1-5ef6fae4b94e653c43db2e14ad0aa5ce.jpg"}}]);