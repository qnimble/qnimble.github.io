(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{79:function(e,a,n){"use strict";n.r(a),n.d(a,"frontMatter",(function(){return o})),n.d(a,"metadata",(function(){return c})),n.d(a,"toc",(function(){return l})),n.d(a,"default",(function(){return s}));var t=n(3),i=n(7),r=(n(0),n(108)),o={},c={unversionedId:"Software/ADC",id:"Software/ADC",isDocsHomePage:!1,title:"ADC",description:'The following functions are available for each of the 4 ADC channels. The "X" in the function name must be replaced by the channel number (1,2,3 or 4):',source:"@site/quarto/Software/ADC.md",slug:"/Software/ADC",permalink:"/Quarto/Software/ADC",version:"current",sidebar:"quarto_main_sidebar",previous:{title:"PID Servo",permalink:"/Quarto/Examples/Servo"}},l=[{value:"configureADCX",id:"configureadcx",children:[{value:"Example",id:"example",children:[]}]},{value:"disableADCX",id:"disableadcx",children:[]},{value:"readADCRAWX",id:"readadcrawx",children:[]},{value:"readADCX_FRom_ISR",id:"readadcx_from_isr",children:[]}],d={toc:l};function s(e){var a=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(t.a)({},d,n,{components:a,mdxType:"MDXLayout"}),Object(r.b)("p",null,'The following functions are available for each of the 4 ADC channels. The "X" in the function name must be replaced by the channel number (1,2,3 or 4):'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#configureadcx"},"configureADCX")),Object(r.b)("li",{parentName:"ul"},"disableADCX"),Object(r.b)("li",{parentName:"ul"},"readADCRAWX_from_ISR"),Object(r.b)("li",{parentName:"ul"},"readADCX_from_ISR")),Object(r.b)("h2",{id:"configureadcx"},"configureADCX"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"void configureADCX(uint16_t fire_every_us, uint16_t fire_delay, adc_scale_t scale, void (*function)(void) );\n")),Object(r.b)("p",null,"This function configures the ADC voltage range, when the ADC reads a voltage and what function to call when new ADC data is ready. The function takes the following arguments:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"fire_every_us"),": 16-bit unsigned integer specifying how many \u03bcs to wait between ADC readings. The smallest value allowed is 1, which tells the ADC to fire every \u03bcs, or at 1 MHz. Since the ADC has a max data rate of 1 mega samples per second (MSPS), running at 1 MHz maximizes the ADC data rate and the remaining ADC channels cannot be used. The max value to 65535 which causes to teh ADC to read data every 65,535 \u03bcs, or at 15.26 Hz.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"fire_delay"),": 16-bit unsigned integer specifying how many \u03bcs to wail before firing. This controls the timing relationship for reading the voltage between multiple channels. If two channels are configured to fire every 10\u03bcs, then setting the ",Object(r.b)("inlineCode",{parentName:"p"},"fire_delay")," to 0 and 1 for the two active channels would have the two channels to fire 1\u03bcs apart and then wait 10\u03bcs before reading data again. Alternatively, setting  ",Object(r.b)("inlineCode",{parentName:"p"},"fire_delay")," to 0 and 5 for the two active channels has the second channel read ADC data 5\u03bcs after the first channel collects data. In this setup, ADC data is read every 5\u03bcs, toggling the active channel each time. ")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"scale"),": Configures the input voltage range the for ADC. Valid options are:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"BIPOLAR_1250mV"),"  : \xb11.25V max range"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"BIPOLAR_2500mV"),": \xb12.5V max range"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"BIPOLAR_5V"),": \xb15V max range"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"BIPOLAR_10V"),": \xb110V max range"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"function"),": Function to call when ADC has new data. Function must take no arguments, nor return anything. This should have the structure of"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-c"},"void custom_function(void)\n")),Object(r.b)("div",{parentName:"li",className:"admonition admonition-caution alert alert--warning"},Object(r.b)("div",{parentName:"div",className:"admonition-heading"},Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",{parentName:"h5",className:"admonition-icon"},Object(r.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},Object(r.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"Make sure to call readADCX_from_ISR()!!")),Object(r.b)("div",{parentName:"div",className:"admonition-content"},Object(r.b)("p",{parentName:"div"},"This custom function must call either readADCX_From_ISR or readADCRAWX_From_ISR (and X must match the channel). This clears the interrupt saying there is ADC data at the ready. If this is not called, the program will run the custom function over and over again and the ",Object(r.b)("em",{parentName:"p"},"Quarto")," will crash. "))))),Object(r.b)("h3",{id:"example"},"Example"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"configureADC1(5, 0, BIPOLAR_1250mV, getADC1); //\xb11.25V, runs every 5\u03bcs\nconfigureADC2(10, 1, BIPOLAR_2500mV, getADC2); //\xb12.5V, runs every 10\u03bcs, 1\u03bc after ADC1 is read\nconfigureADC3(10, 7, BIPOLAR_5V, getADC3); //\xb15V, runs every 10\u03bcs, 6\u03bc after ADC2 is read\nconfigureADC4(10, 8, BIPOLAR_10V, getADC4);//\xb110V, runs every 10\u03bcs, 8\u03bc after ADC2 is read\n\nvoid gotADC1(void) {\n    double newadc = readADC1_from_ISR(); //Read ADC data as a double\n    ...\n}\nvoid gotADC2(void) {\n    double newadc = readADC2_from_ISR(); //Read ADC data as a double\n    ...\n}\nvoid gotADC3(void) {\n    int16_t newadc = readADCRAW3_from_ISR(); //Read ADC data as an signed 16-bit integer\n    ...\n}\nvoid gotADC4(void) {\n    int16_t newadc = readADCRAW4_from_ISR(); //Read ADC data as an signed 16-bit integer\n    ...\n}\n\n")),Object(r.b)("h2",{id:"disableadcx"},"disableADCX"),Object(r.b)("h2",{id:"readadcrawx"},"readADCRAWX"),Object(r.b)("h2",{id:"readadcx_from_isr"},"readADCX_FRom_ISR"))}s.isMDXComponent=!0}}]);