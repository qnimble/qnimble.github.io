"use strict";(self.webpackChunkdoc_source=self.webpackChunkdoc_source||[]).push([[829],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),c=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,u=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(u,".").concat(h)]||d[h]||p[h]||l;return n?a.createElement(m,i(i({ref:t},s),{},{components:n})):a.createElement(m,i({ref:t},s))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6088:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return u},metadata:function(){return c},toc:function(){return s},default:function(){return d}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),i=["components"],o={toc_max_heading_level:2},u=void 0,c={unversionedId:"Software/DAC",id:"Software/DAC",title:"DAC",description:"The following general DAC functions are available to set the Analog Output voltage. They take a DAC channel as an argument along with the DAC value.",source:"@site/Quarto/Software/DAC.md",sourceDirName:"Software",slug:"/Software/DAC",permalink:"/Quarto/Software/DAC",tags:[],version:"current",frontMatter:{toc_max_heading_level:2},sidebar:"quarto_main_sidebar",previous:{title:"ADC",permalink:"/Quarto/Software/ADC"},next:{title:"Digital I/O",permalink:"/Quarto/Software/Digital"}},s=[{value:"writeDAC",id:"writedac",children:[{value:"Example",id:"example",children:[],level:3}],level:2},{value:"writeDACRAW",id:"writedacraw",children:[{value:"Example",id:"example-1",children:[],level:3}],level:2},{value:"writeDACX",id:"writedacx",children:[{value:"Example",id:"example-2",children:[],level:3}],level:2},{value:"writeDACXRAW",id:"writedacxraw",children:[{value:"Example",id:"example-3",children:[],level:3}],level:2},{value:"zeroDACs",id:"zerodacs",children:[{value:"Example",id:"example-4",children:[],level:3}],level:2}],p={toc:s};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The following general DAC functions are available to set the Analog Output voltage. They take a DAC channel as an argument along with the DAC value."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#writedac"},"writeDAC")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#writedacraw"},"writeDACRAW")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#zerodacs"},"zeroDACs"))),(0,l.kt)("h2",{id:""}),(0,l.kt)("p",null,'Additionally, these channel-specific functions are available for each of the 4 DAC channels as well. The "X" in the function name must be replaced by the channel number (1,2,3 or 4). While the functionality is the same as the above functions, these run a bit faster as they do not have to calculate the channel to update. If you need to save a few clock cycles, use these functions. Otherwise (or if you are unsure) stick with ',(0,l.kt)("a",{parentName:"p",href:"#writedac"},"writeDAC")," and ",(0,l.kt)("a",{parentName:"p",href:"#writedacraw"},"writeDACRAW"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#writedacx"},"writeDACX")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#writedacxraw"},"writeDACXRAW"))),(0,l.kt)("h2",{id:"writedac"},"writeDAC"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"void writeDAC(int channel, float voltage);\nvoid writeDAC(int channel, double voltage);\n")),(0,l.kt)("p",null,"This function writes a voltage to the DAC channel ",(0,l.kt)("inlineCode",{parentName:"p"},"channel"),". It takes either a float or a double as an input. (Technically, writeDAC is overcast with two functions, one that takes a double and one that takes a float as an argument, but this detail can be ignored.)  The function takes the following arguments:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"channel"))," DAC channel to update. Valid values are 1, 2, 3 or 4."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"voltage"))," The voltage to output on the DAC channel ",(0,l.kt)("inlineCode",{parentName:"li"},"channel"),". Values above +10V or below -10V will be coerced to +10V or -10V respectively.  Type float or double is accepted.")),(0,l.kt)("h3",{id:"example"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"IntervalTimer Timer; // instantiate a timer for setting the DAC update rate\ndouble voltage_pattern[] = {1.25,1.3,1.4534,2.453,2.6534,3,4,-2,-3.423} ; // array of voltages\n\nvoid setup() {\n  Timer.begin(ddsUpdate, 10); // update every 10 microseconds\n}\n\nvoid ddsUpdate() {  \n  static unsigned int position = 0; //store position in array\n  writeDAC(1,voltage_pattern[position]);  // set DAC channel 1 to next value array\n  writeDAC(2,-voltage_pattern[position]); // set DAC channel 2 to negative of next value in array\n  \n  position++; // Increment to next value in array\n  if ( position >= ( sizeof(voltage_pattern)/sizeof(voltage_pattern[0]) ) ) { \n      //reset positition when position equal to number of elements in voltage_pattern\n      position = 0;\n  }\n}\n")),(0,l.kt)("h2",{id:"writedacraw"},"writeDACRAW"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"void writeDACRAW(int channel, int16_t data);\n")),(0,l.kt)("p",null,"This function writes a signed 16-bit integer to the DAC on channel ",(0,l.kt)("inlineCode",{parentName:"p"},"channel"),".  The function takes the following arguments:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"channel"))," DAC channel to update. Valid values are 1, 2, 3 or 4."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"data"))," A signed 16-bit integer that is the raw data sent to the DAC on channel ",(0,l.kt)("inlineCode",{parentName:"li"},"channel"),".  The voltage on the DAC is equal to the integer value times 10.24 / 32768 = 3.125e-4. An integer value of 16,384 will output +5.12V. And value of -16,384 will output -5.12V. Values above +10V or below -10V will be coerced to +10V or -10V respectively. ")),(0,l.kt)("h3",{id:"example-1"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"IntervalTimer Timer; // instantiate a timer for setting the DAC update rate\nint16_t voltage_pattern[] = {-23432,-10342,-5432,-43,543,1532,15342}; // Raw DAC values\n\nvoid setup() {\n    Timer.begin(ddsUpdate, 10); // update every 10 microseconds\n}\n\nvoid ddsUpdate() {  \n    static unsigned int position = 0; //store position in array\n    writeDACRAW(1,voltage_pattern[position]);  // set DAC channel 1 to next value array\n    writeDACRAW(2,-voltage_pattern[position]); // set DAC channel 2 to negative of next value in array\n    \n    position++; // Increment to next value in array\n    if ( position >= ( sizeof(voltage_pattern)/sizeof(voltage_pattern[0]) ) ) { \n        //reset positition when position equal to number of elements in voltage_pattern\n        position = 0;\n    }\n}\n")),(0,l.kt)("h2",{id:"writedacx"},"writeDACX"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"void writeDACX(double voltage);\nvoid writeDACX(float voltage);\n")),(0,l.kt)("p",null,"This function is identical to ",(0,l.kt)("a",{parentName:"p",href:"#writedac"},"writeDAC"),", except it does not take a channel argument, as the channel is set by the function called. It takes either a float or a double as an input. (Technically, writeDACX is overcast with two functions, one that takes a double and one that takes a float as an argument, but this detail can be ignored.)"),(0,l.kt)("p",null,"The function takes the following argument:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"voltage")),"  The voltage to output on the DAC channel X. Values above +10V or below -10V will be coerced to +10V or -10V respectively. ")),(0,l.kt)("h3",{id:"example-2"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"writeDAC2(-4.562); //Write -4.562 volts to DAC channel 2\nwriteDAC4(3.14); //Write 3.14 volts to DAC channel 4\n")),(0,l.kt)("h2",{id:"writedacxraw"},"writeDACXRAW"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"void writeDACRAWX(int16_t data);\n")),(0,l.kt)("p",null,"This function writes a signed 16-bit integer to the DAC on channel X. "),(0,l.kt)("p",null,"The function takes the following argument:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"data"))," a signed 16-bit integer that is the raw data sent to the DAC.  The voltage on the DAC is equal to the integer value times 10.24 / 32768 = 3.125e-4. An integer value of 16,384 will output +5.12V. And value of -16,384 will output -5.12V.")),(0,l.kt)("h3",{id:"example-3"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int16_t data = 16384;\nwriteDACRAW(2,data); //Write 16,384 or 5.12V volts to DAC channel 2\ndata -= 24576;\nwriteDACRAW(4,data); //Write -8192 or -2.56 volts to DAC channel 4\n")),(0,l.kt)("h2",{id:"zerodacs"},"zeroDACs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"void zeroDACs(void);\n")),(0,l.kt)("p",null,"This function sets all four DAC's output to 0V. The function takes no arguments."),(0,l.kt)("h3",{id:"example-4"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"float output = 0;\nif (running) {\n    output += 0.25;\n    writeDAC(1,output);\n    writeDAC(2,-output);\n} else {\n    zeroDACs();\n}\n\n")))}d.isMDXComponent=!0}}]);